use crate::ray::Ray;
use crate::hitable_list::HittableList;
use crate::interval::Interval;
use crate::colour::{Colour, write_color};
use vec3math::{Point3, Vec3};

use std::fs::File;
use std::io::prelude::*;

const MESSAGE: &str = "# Generated By Rust Ray Tracer\n# https://github.com/TheBigBakedBean/rust_ray_tracer";
const DEFAULT_FOCAL_LENGTH: f64 = 1.0;
const DEFAULT_VIEWPORT_HEIGHT: f64 = 2.0;

#[derive(Default)]
pub struct Camera{
    pub image_width: i32,
    pub aspect_ratio: f64,
    image_height: i32,
    center: Point3,
    pixel00_loc: Point3,
    pixel_delta_horizontal: Vec3,
    pixel_delta_vertical: Vec3,
}

impl Camera{
    pub fn new(image_width: i32, aspect_ratio: f64) -> Self{

        // Initialize a base camera with default parameters so we can call initialize()
        let mut temp = Camera{
            image_width,
            aspect_ratio,
            ..Default::default()
        };

        temp.initialize();

        temp
    }

    fn initialize(&mut self){

        // Calculate image height, ensuring it's at least 1
        self.image_height = (f64::from(self.image_width) / self.aspect_ratio) as i32;
        self.image_height = i32::max(self.image_height, 1);

        self.center = Point3::new(0.0, 0.0, 0.0);

        // Determine viewport dimensions
        let focal_length = DEFAULT_FOCAL_LENGTH;
        let viewport_height = DEFAULT_VIEWPORT_HEIGHT;
        let viewport_width = viewport_height * self.aspect_ratio;

        // Horizontal and Vertical vectors along the edges of the viewport that intersect at the origin
        let viewport_horizontal_vector = Vec3::new(viewport_width, 0.0, 0.0);
        let viewport_vertical_vector = Vec3::new(0.0, -viewport_height, 0.0);

        // Horizontal and Vertical vectors between adjacent pixels
        self.pixel_delta_horizontal = viewport_horizontal_vector / self.image_width.into();
        self.pixel_delta_vertical = viewport_vertical_vector / self.image_height.into();

        // Calculate the location of the top left pixel
        let viewport_upper_left = self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_horizontal_vector / 2.0 - viewport_vertical_vector / 2.0;
        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_horizontal + self.pixel_delta_vertical);

    }

    pub fn render(&self, world: &HittableList, file: &mut File) -> std::io::Result<()>{
        writeln!(file, "P3\n\n{}\n\n{} {}\n255\n", MESSAGE, self.image_width, self.image_height)?;

        // Output a comment to show if debug mode is active
        #[cfg(debug_assertions)]
        writeln!(file, "# DEBUG MODE ACTIVE")?;

        // Iterate over pixel coordinates
        for y in 0..self.image_height{
            print!("\rScanlines remaining: {} ", self.image_height - y);
            std::io::stdout().flush().ok();
            
            // Convert y into a float once to avoid casting many times
            let fy = f64::from(y);

            for x in 0..self.image_width{
                let fx = f64::from(x);

                let pixel_center = self.pixel00_loc + (self.pixel_delta_horizontal * fx) + (self.pixel_delta_vertical * fy);
                let ray_direction = pixel_center - self.center;
                let ray = Ray::new(self.center, ray_direction);

                let pixel_colour = Self::ray_colour(&ray, &world);
                write_color(file, &pixel_colour)?;
            }
        }

        println!("\rDone.                                     ");

        Ok(())
    }

    fn ray_colour(ray: &Ray, world: &HittableList) -> Colour{
        match world.hit(ray, Interval::new(0.0, crate::INFINITY)){
            Some(e) => {
                
                // Return a colour based on the surface normals
                0.5 * (e.normal + Colour::new(1.0, 1.0, 1.0))
            },
            None => {
                
                // Generate a blue gradient for the background when the ray doesn't hit anything
                let unit_direction = ray.dir.normalized();
                let a = 0.5 * (unit_direction.y + 1.0);
                (1.0 - a) * Colour::new(1.0, 1.0, 1.0) + a * Colour::new(0.5, 0.7, 1.0)
            }
        }
    }
}