use crate::ray::Ray;
use crate::hitable_list::HittableList;
use crate::interval::Interval;
use crate::colour::{Colour, write_color};
use crate::random_f64;
use vec3math::{Point3, Vec3, dot};

use std::fs::File;
use std::io::prelude::*;

const MESSAGE: &str = "# Generated By Rust Ray Tracer\n# https://github.com/TheBigBakedBean/rust_ray_tracer";
const DEFAULT_FOCAL_LENGTH: f64 = 1.0;
const DEFAULT_VIEWPORT_HEIGHT: f64 = 2.0;
const GAMUT: f64 = 0.5;

#[derive(Default)]
pub struct Camera{
    pub image_width: i32,
    pub aspect_ratio: f64,
    pub samples_per_pixel: i32,
    pub max_depth: i32,

    image_height: i32,
    center: Point3,
    pixel00_loc: Point3,
    pixel_delta_horizontal: Vec3,
    pixel_delta_vertical: Vec3,
    pixel_samples_scale: f64,
}

impl Camera{
    pub fn new(image_width: i32, aspect_ratio: f64, samples_per_pixel: i32, max_depth: i32) -> Self{

        // Initialize a base camera with default parameters so we can call initialize()
        let mut temp = Camera{
            image_width,
            aspect_ratio,
            samples_per_pixel,
            max_depth,
            ..Default::default()
        };

        temp.initialize();

        temp
    }

    fn initialize(&mut self){

        // Calculate image height, ensuring it's at least 1
        self.image_height = (f64::from(self.image_width) / self.aspect_ratio) as i32;
        self.image_height = i32::max(self.image_height, 1);

        self.pixel_samples_scale = 1.0 / f64::from(self.samples_per_pixel);

        self.center = Point3::new(0.0, 0.0, 0.0);

        // Determine viewport dimensions
        let focal_length = DEFAULT_FOCAL_LENGTH;
        let viewport_height = DEFAULT_VIEWPORT_HEIGHT;
        let viewport_width = viewport_height * self.aspect_ratio;

        // Horizontal and Vertical vectors along the edges of the viewport that intersect at the origin
        let viewport_horizontal_vector = Vec3::new(viewport_width, 0.0, 0.0);
        let viewport_vertical_vector = Vec3::new(0.0, -viewport_height, 0.0);

        // Horizontal and Vertical vectors between adjacent pixels
        self.pixel_delta_horizontal = viewport_horizontal_vector / self.image_width.into();
        self.pixel_delta_vertical = viewport_vertical_vector / self.image_height.into();

        // Calculate the location of the top left pixel
        let viewport_upper_left = self.center - Vec3::new(0.0, 0.0, focal_length) - viewport_horizontal_vector / 2.0 - viewport_vertical_vector / 2.0;
        self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_horizontal + self.pixel_delta_vertical);

    }

    pub fn render(&self, world: &HittableList, file: &mut File) -> std::io::Result<()>{
        writeln!(file, "P3\n\n{}\n\n{} {}\n255\n", MESSAGE, self.image_width, self.image_height)?;

        // Output a comment to show if debug mode is active
        #[cfg(debug_assertions)]
        writeln!(file, "# DEBUG MODE ACTIVE")?;

        // Iterate over pixel coordinates
        for y in 0..self.image_height{
            print!("\rScanlines remaining: {} ", self.image_height - y);
            std::io::stdout().flush().ok();
            
            // Convert y into a float once to avoid casting many times
            let fy = f64::from(y);

            for x in 0..self.image_width{
                let fx = f64::from(x);

                let mut pixel_colour = Colour::new(0.0, 0.0, 0.0);

                for _sample in 0..self.samples_per_pixel{
                    let ray = self.get_ray(fx, fy);
                    pixel_colour += Self::ray_colour(&ray, world, self.max_depth, GAMUT);
                }

                let average_pixel_colour = pixel_colour * self.pixel_samples_scale;

                write_color(file, &average_pixel_colour)?;
            }
        }

        println!("\rDone.                                     ");

        Ok(())
    }

    // Uses floating point inputs to avoid casting multiple times
    fn get_ray(&self, fx: f64, fy: f64) -> Ray{
        // Construct a camera ray originating from the origin and directed at randomly sample points around the pixel coordinate given

        let offset = Self::sample_square();
        let pixel_sample = self.pixel00_loc
            + (fx + offset.x) * self.pixel_delta_horizontal
            + (fy + offset.y) * self.pixel_delta_vertical;

        Ray::new(self.center, pixel_sample - self.center)
    }

    fn ray_colour(ray: &Ray, world: &HittableList, depth: i32, gamut: f64) -> Colour{
        if depth <= 0 {
            return Colour::new(0.0, 0.0, 0.0)
        }

        match world.hit(ray, Interval::new(0.001, crate::INFINITY)){
            Some(e) => {
                let direction = e.normal + Self::random_unit_vector();
                gamut * Self::ray_colour(&Ray::new(e.point, direction), world, depth - 1, gamut)
            },
            None => {
                
                // Generate a blue gradient for the background when the ray doesn't hit anything
                let unit_direction = ray.dir.normalized();
                let a = 0.5 * (unit_direction.y + 1.0);
                (1.0 - a) * Colour::new(1.0, 1.0, 1.0) + a * Colour::new(0.5, 0.7, 1.0)
            }
        }
    }

    fn sample_square() -> Vec3 {
        // Returns the vector to a random point in the [-0.5, -0.5] - [+0.5, +0.5] unit square

        return Vec3::new(random_f64() - 0.5, random_f64() - 0.5, 0.0);
    }

    fn random_unit_vector() -> Vec3{
        loop{
            let p = crate::random_vec3_range(-1.0, 1.0);
            let lensq = p.length_squared();
            if 1e-160 < lensq && lensq <= 1.0{
                return p / lensq.sqrt()
            }
        }
    }

    fn random_on_hemisphere(normal: &Vec3) -> Vec3{
        let on_unit_sphere = Self::random_unit_vector();
        if dot(&on_unit_sphere, normal) > 0.0 {
            on_unit_sphere
        } else {
            -on_unit_sphere
        }
    }
}